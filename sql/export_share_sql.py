from __future__ import annotations

import argparse
import datetime as dt
from decimal import Decimal
from pathlib import Path

from sqlalchemy import create_engine, inspect, text

from app.core.config import get_settings

DEFAULT_TABLES = [
    "community",
    "community_metrics",
    "community_context",
    "review_post",
    "review_signal",
    "dimension_score",
    "community_comparison",
]


def main() -> None:
    args = parse_args()
    settings = get_settings()
    engine = create_engine(settings.database_url)
    inspector = inspect(engine)
    table_names = set(inspector.get_table_names())

    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("-- Auto-generated SQL share bundle")
    lines.append("-- Generated by: python -m scripts.export_share_sql")
    lines.append("")

    if args.include_schema:
        schema_path = Path("sql/1_create_tables.sql")
        if schema_path.exists():
            lines.append("-- ===== BEGIN SCHEMA =====")
            lines.extend(schema_path.read_text(encoding="utf-8").splitlines())
            lines.append("-- ===== END SCHEMA =====")
            lines.append("")

    with engine.begin() as conn:
        for table in DEFAULT_TABLES:
            if table not in table_names:
                lines.append(f"-- Skip missing table: {table}")
                continue
            lines.extend(_export_table(conn, inspector, table))
            lines.append("")

    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"SQL exported to {output_path}")


def parse_args():
    parser = argparse.ArgumentParser(description="Export DB rows to SQL INSERT statements for sharing.")
    parser.add_argument(
        "--output",
        default="sql/2_insert_statements.sql",
        help="Output SQL file path (default: sql/2_insert_statements.sql).",
    )
    parser.add_argument(
        "--include-schema",
        action="store_true",
        help="Prepend sql/1_create_tables.sql into the output bundle.",
    )
    return parser.parse_args()


def _export_table(conn, inspector, table: str) -> list[str]:
    columns = [col["name"] for col in inspector.get_columns(table)]
    quoted_cols = ", ".join(columns)
    rows = conn.execute(text(f"SELECT {quoted_cols} FROM {table}")).mappings().all()

    lines = [f"-- Table: {table}", f"DELETE FROM {table};"]
    if not rows:
        lines.append(f"-- No rows in {table}")
        return lines

    for row in rows:
        values_sql = ", ".join(_to_sql_literal(row[col]) for col in columns)
        lines.append(f"INSERT INTO {table} ({quoted_cols}) VALUES ({values_sql});")
    return lines


def _to_sql_literal(value) -> str:
    if value is None:
        return "NULL"
    if isinstance(value, bool):
        return "TRUE" if value else "FALSE"
    if isinstance(value, (int, float, Decimal)):
        return str(value)
    if isinstance(value, (dt.datetime, dt.date, dt.time)):
        return "'" + value.isoformat(sep=" ") + "'"
    text_value = str(value).replace("'", "''")
    return f"'{text_value}'"


if __name__ == "__main__":
    main()
